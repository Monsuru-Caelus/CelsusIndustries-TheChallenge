### **Technical Specification: The Celsus Challenge Simulation**

**1. Overview**

This is a 2D side-scrolling simulation environment designed to model the core physics of a hybrid aquatic-aerial vehicle. The world consists of two distinct mediums, "air" and "water," separated by a surface line. The user's goal is to write control and autonomy logic in Python to pilot one or more vehicles to complete specific objectives.

**2. Technology Stack**

  * **Language:** Python 3.9+
  * **Library:** `Pygame` for visualization and the main loop.

**3. Project Structure**

```
caelus_challenge/
├── main.py                 # Main simulation loop
├── config.py               # All constants (gravity, densities, etc.)
├── world.py                # Manages the environment (air/water, targets)
├── vehicle.py              # The hybrid vehicle class with physics
├── utils.py                # Helper functions (e.g., vector math)
|
├── track_1_robotics.py       # User entry point for Track 1
├── controller.py             # **USER EDITS THIS FOR TRACK 1**
|
├── track_2_autonomy.py       # User entry point for Track 2
└── mission_planner.py      # **USER EDITS THIS FOR TRACK 2**
```

**4. Core Physics Model**

The `Vehicle` class will be a point mass subject to several forces on each frame update. The physics will be a simplified model focusing on the key dynamics.

  * **Forces Acting on the Vehicle:**

      * **Gravity ($F_g$):** A constant downward force, $F_g = mass \cdot g$.
      * **Thrust ($F_t$):** A vector controlled by the user's code. The magnitude and direction of thrust will be set by the user's controller.
      * **Buoyancy ($F_b$):** An upward force that applies *only* when the vehicle is submerged. $F_b = \rho_{water} \cdot g \cdot V_{vehicle}$.
      * **Drag ($F_d$):** A force opposing velocity. This is the key to the simulation's realism. The formula is $F_d = -0.5 \cdot \rho_{medium} \cdot |v|^2 \cdot C_d \cdot A \cdot \hat{v}$.
          * The crucial variable is $\rho_{medium}$ (density), which will be dramatically higher in water than in air, creating the "impact" and resistance.

  * **Integration:** We'll use simple Euler integration to update the vehicle's state:

    1.  Sum all forces: $F_{net} = F_g + F_t + F_b + F_d$.
    2.  Calculate acceleration: $a = F_{net} / mass$.
    3.  Update velocity: $v_{t+1} = v_t + a \cdot \Delta t$.
    4.  Update position: $p_{t+1} = p_t + v_{t+1} \cdot \Delta t$.

-----

### **Boilerplate Code & Class Definitions**

Here is the foundational code structure.

#### **`config.py`**

```python
# --- Simulation Constants ---
SCREEN_WIDTH = 1200
SCREEN_HEIGHT = 800
FPS = 60

# --- World Constants ---
WATER_LEVEL = SCREEN_HEIGHT / 2
GRAVITY = 9.81
AIR_DENSITY = 1.225   # kg/m^3
WATER_DENSITY = 1000  # kg/m^3

# --- Vehicle Constants ---
VEHICLE_MASS = 218.6  # kg (From research paper)
VEHICLE_VOLUME = 0.2133 # m^3 (To be neutrally buoyant at 218.6kg)
DRAG_COEFFICIENT = 0.5 # Simplified
FRONTAL_AREA = 0.125  # m^2 (Effective area)
MAX_THRUST = 8000     # Newtons
G_FORCE_LIMIT = 12.0  # Max G's before "crash" in Track 1

# --- Track 2 Constants ---
SWARM_SIZE = 2
SENSOR_RANGE = 200 # pixels
```

#### **`vehicle.py`**

```python
import pygame
import math
from config import *
from utils import Vector2

class Vehicle:
    def __init__(self, position, mass, volume):
        self.position = Vector2(position[0], position[1])
        self.velocity = Vector2(0, 0)
        self.acceleration = Vector2(0, 0)
        self.mass = mass
        self.volume = volume
        self.is_submerged = False
        self.thrust_vector = Vector2(0, 0)

    def apply_physics(self, medium_density, dt):
        # 1. Gravity
        gravity_force = Vector2(0, self.mass * GRAVITY)

        # 2. Buoyancy (only if submerged)
        buoyancy_force = Vector2(0, 0)
        if self.is_submerged:
            buoyancy_force = Vector2(0, -WATER_DENSITY * GRAVITY * self.volume)

        # 3. Drag
        drag_magnitude = 0.5 * medium_density * self.velocity.magnitude_squared() * DRAG_COEFFICIENT * FRONTAL_AREA
        drag_force = self.velocity.normalized() * -drag_magnitude if self.velocity.magnitude() > 0 else Vector2(0, 0)

        # 4. Thrust (set by user controller)
        thrust_force = self.thrust_vector
        
        # --- Sum forces and update state ---
        net_force = gravity_force + buoyancy_force + drag_force + thrust_force
        self.acceleration = net_force / self.mass
        self.velocity += self.acceleration * dt
        self.position += self.velocity * dt

    def set_thrust(self, direction_angle_deg, magnitude):
        magnitude = min(magnitude, MAX_THRUST)
        rads = math.radians(direction_angle_deg - 90) # Adjust for pygame coordinates
        self.thrust_vector = Vector2(math.cos(rads) * magnitude, math.sin(rads) * magnitude)
    
    # Other methods like draw(), check_submerged(), etc.
```

#### **`controller.py` (For Track 1)**

```python
# ********************************************** #
# ** USER EDITS THIS FILE FOR TRACK 1 **
# ********************************************** #

class UserVehicleController:
    """
    This is the class you will edit to control the vehicle for Track 1.
    """
    def __init__(self):
        # You can initialize any variables you need here
        self.state = "DESCENDING"

    def compute_control(self, vehicle_state):
        """
        This method is called every frame. You must return a tuple of (thrust_angle, thrust_magnitude).

        Args:
            vehicle_state (dict): A dictionary containing the vehicle's current state.
                {
                    "position": (x, y),
                    "velocity": (vx, vy),
                    "acceleration": (ax, ay),
                    "is_submerged": bool
                }
        
        Returns:
            tuple: (thrust_angle_degrees, thrust_magnitude_newtons)
                   - thrust_angle: 0 is up, 90 is right, 180 is down, 270 is left.
                   - thrust_magnitude: A value from 0 to MAX_THRUST.
        """
        
        # --- YOUR LOGIC HERE ---
        # Example: Simple logic to slow down before hitting water
        pos_y = vehicle_state["position"][1]
        vel_y = vehicle_state["velocity"][1]
        
        # If we are above water and falling fast
        if not vehicle_state["is_submerged"] and pos_y < WATER_LEVEL - 100 and vel_y > 5:
            # Apply reverse thrust
            return (0, MAX_THRUST / 2) # Apply 50% thrust upwards
        
        # Once submerged, apply thrust to breach
        if vehicle_state["is_submerged"]:
            return (0, MAX_THRUST) # Full power upwards
            
        return (0, 0) # Default: no thrust
```
